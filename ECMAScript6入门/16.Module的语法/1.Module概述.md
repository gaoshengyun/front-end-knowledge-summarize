## Module概述

历史上,JavaScript一直没有模块(module)体系,无法将一个大程序拆分成互相依赖的小文件,再用简单的方法拼装起来.其他语言都有这项功能,比如Ruby的require,Python的import,甚至连css都有@import,但是JavaScript任何这方面的支持都没有.这对开发大型的,复杂的项目形成了巨大的障碍.

在ES6之前,社区制定了一些模块加载方案,最主要的有CommonJS和AMD两种.前者用于服务器,后者用于浏览器.ES6在语言标准层面上,实现了模块功能,而且实现得当相当简单,完全可以取代CommonJS和AMD规范,成为浏览器和服务器能用的模块解决方案.

ES6模块的设计思想是尽量静态化,使得编译时就能确定模块的依赖关系,以及输入和输出的变量.CommonJS和AMD模块,都只能在运行时确定这些东西,比如,CommonJS模块就是对象,输入时必须查找对象属性.
```
// CommonJS模块
let {stat,exists,readFile} = require('fs')

// 等同于
let _fs = require('fs')
let stat = _fs.stat
let exists = _fs.exists
let readFile = _fs.readFile
```
上面代码的实质是整体加载fs模块,(即加载fs的所有方法),生成一个对象(_fs),然后再从这个对象上面读取3个方法,这种载称为运行时加载,因它只有运行时才能得到这个对象,导致完全没有办法在编译时静态优化.

ES6模块不是对象,而是通过export命令显示地指定输出的代码,再通过import命令输入.
```
// ES6模块
import {stat,exists,readFile} from 'fs'
```
上面代码的实质是从fs模块加载3个方法,其他方法不加载.这种加载称为编译时加载或静态加载,即ES6可以在编译时就完成模块加载,效率要比CommonJS模块的加载方式高,当然这也导致了没法引用ES6模块本身,因为它不是对象.

由于ES6模块是编译时加载,使得瞬态分析成为可能,有了它,就能进一步拓宽JavaScript的语法,比如引入宏和类型检验这些唑能靠静态分析实现的功能.

除了静态加载带来的各种好处,ES6模块还有以下好处
- 不需要用UMD模块格式了,将来服务器和浏览器都会支持ES6模块格式.目前,通过各种工具库已经可以做到这一点了.
- 将来浏览器的新API就能用模块格式提供,不再必须做成全局变量或者navigator对象的属性
- 不再需要对象作为命名空间,不想来这些功能可以通过模块提供.
