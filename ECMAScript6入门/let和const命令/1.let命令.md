## let命令
**基本用法**
>es6新增了let命令,用来声明变量,它的用法类似于var,但是所声明的变量,只有let命令所在的代码块内有效.
```
{
  let a = 10
  var b = 1
}
console.log(a) //报错:a is not defined
console.log(b) //1
```
>上面的代码在茇块之中,分别用let和var声明了两个变量,然后在代码块之外调用这两个变量,结果let声明的变量报错,var声明的变量正常返回值,这表明,let声明的变量只在它所在的代码块内有效.

>for循环的计数器,很合适用let命令
```
for(let i = 0;i < 10;i++){
  //...
}
console.log(i)  //报错:i is not defined
```
>上面代码中,计数器i只在for循环体内有效,在循环体外线上服务会报错.

>下面的代码如果使用var,最后输出的是10
```
var a = []
for(var i = 0;i < 10;i++){
  a[i] = function(){
    console.log(i)
  }
}
a[6]()    //10
```
>上面代码中,变量i是var命令声明的,在全局范围内有效,所以全局只有一个变量i.每一次循环,变量i的值都会发 生改变,而循环内被赋给数组a的函数内部的console.log(i),里面的i指向的就是全局的i.也就是说,所有数组a的成员里面的i,指向的都是同一个i,导致运行时输出的是最后一轮的i的值,也就是10.

>如果使用let,地暖的变量仅在作用域内有效,最后输出的就是6
```
var a = []
for(let i = 0;i < 10;i++){
  a[i] = function(){
    console.log(i)
  }
}
a[6]()    //6
```
>上面代码中,变量i是let声明的,当前的i只在本轮循环有效,所以每一次循环的i其实都是一个新的变量,所以最后输出的是6.你可能会问,如果每一轮循环的变量i都是重新声明的,那么它怎么知道上一轮循环的值,从而计算出本轮循环的值?这是因为JavaScript引擎内部会记住上一轮循环的值,寝化本轮的变量i时,就在上一轮循环的基础上进行计算

>另外,for循环还有一个特别之处,就是设置循环变量的那部分是一个父作用域,而循环体内是单独的子作用域
```
for(let i = 0;i < 3,i++){
  let i = 'abc'
  console.log(i)
}
//abc
//abc
//abc
```
>上面的代码正确运行,输出了3次abc,这不及时函数内部的变量i与循环变量i不在同一个作用域,有各自单独的作用域
---
**不存在变量提升**
>var命令会发生变量提交现象,妈变量可以在声明之前使用,值为undefined,这种现象多多少少是有些奇怪,按照一般的逻辑,变量应该在声明语句之后才可以使用.

>为了纠正这种现象,let命令改变了语法行为,它所有声明的变量一定要在声明后使用,否则报错
```
//var的情况
console.log(foo)  //输出undefined
var foo = 2

//let情况
console.log(bar)  //报错
let bar = 2
```
>上面代码中,变量foo用var命令声明,会发生变量提升,即脚本开始运行时,变量foo已经存在,但是没有值,所以会输出undefined,变量bar用let命令声明,不会发生变量提升,这表示在声明之前,变量bar是不存在的,这时如果用到它,就会抛出一个错误.
---
**暂时性死区**
>只要声级作用域内存在let命令,它所声明的变量就是绑定这个区域,不再受外部的影响
```
var tmp = 123

if(true){
  tmp = 'abc'
  let tmp
}
```
>上面代码中,存在全局变量tmp,但是块级作用域内let又声明了一个局部变量tmp,导致后者绑定这个块级作用域,所以 let声明变量前,对tmp会赋值会报错

>ES6中明确规定,如果区块中存在let和const命令,这个区块对这些命令声明的变量,从一开始就形成了封装作用域,凡是在声明之前就使用这些变量,就会报错.

>总之,在代码块内,使用let命令声明变量之前,该变量名都是不可用的,这在语法上称之为暂时性死区(temporal dead zone,简称TDZ)

```
if(true){
  //TDZ开始
  tmp = 'abc' //报错
  console.log(tmp)  //报错

  let tmp //TDZ结束
  console.log(tmp)  //undefined

  tmp = 123
  console.log(tmp)  //123
}
```

>上面代码中,在let命令声明变量let之前,都属于tmp的死区

>暂时性死区也意味着tpyeof不再是一个百分百安全的操作
```
typeof x  //报错
let x
```
>上面代码中,变量x使用let命令,所以在声明之前,都属于x的死区,只要用到该变量就会报错,因为tepeof运行时会报错

>作为比较,如果一个变量根本没有被声明,使用typeof反而不会被报错
```
typeof undeclared_variable  //'undefined'
```
上面代码中,undeclared_variable是一个不存在的变量名,结果返回undefined,所以,在没有let之前,typeof运算符是百分百安全的,永远不会报错,现在这一点不成立了,这样的设计是为了让大家养成郎的编程习惯,变量一定要在声明之后使用,否则会报错

>有些死区比较隐蔽,不太容易被发现
```
function bar(x=y,y=2){
  return [x,y]
}
bar() //报错
```

>上面代码中,调用bar函数之所以报错(某些实现可能不会报错),是因为参数x默认值等于另一个参数y,而此时y还没有声明,属于死区,如果y的默认值是x,就不会报错,因为此时x已声明
```
function bar(x=2,y=x){
  return [x,y]
}
bar()   //[2,2]
```
>另外下面的代码也会报错,与var的行为不同
```
//不报错
var x = y

//报错
let x = x //报错
```
>上面代码报错也是因为暂时性死区,使用let地暖变量时,只要变量在还没有声明完成前使用,就会报错,上面这行就属于这个情况,在变量x的声明语句还没有执行完成前,就会去取x的值,导致报错x未定义

>ES6规定暂时性死区和let,const这顿饭不出现变量提升,主要是为了减少运行时错误,防止在变量声明前就使用这个变量,从而导致意料之外的行为,这样的错误在ES5中很常见,现在有了这种规定,避免此类错误就容易了.

>总之,暂时性死区和let,const语句不出现变量提升,主要是为了减少运行时错误,防止在变量声明前就使用这个变量.
---
**不允许重复声明**
>let不允许在相同作用域内重复声明同一个变量
```
//报错
function func(){
  let a = 10
  var a = 1
}

//报错
function func(){
  var a = 10
  let a = 1
}
```
>不能在函数内部重新声明参数
```
function func(arg){
  let arg
}
func() //报错

function func(arg){
  {
    let arg
  }
}
func() //不报错
```