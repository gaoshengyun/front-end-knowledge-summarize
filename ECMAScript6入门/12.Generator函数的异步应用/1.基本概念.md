## 基本概念
---
**异步**

所谓异步,简单的说是一个任务不是连续完成的,可以理解成该任务被人为分成两段,先执行一段,然后转而执行其他任务,等做好了准备,再加过头来执行第二段.

比如,有一个任务是读取文件进行处理,任务的第一段是向操作系统发出请求,要求读取文件,然后,程序执行其他任务,等到操作系统返回文件,再等着执行任务的第二段处理文件,这种不连续的执行,就叫做异步.

相应地,连续执行就叫做同步,由于是连续执行,不能插入其他任务,所以操作系统从破船读取文件的这段时间,程序只能干等着.

---
**回调函数**

JavaScript语言对异步编程的实现,就是回调函数.所谓回调buiv,就是把任务的第二段单独写在一个函数里,等到重新执行这个任务的时候,就直接调用这个函数.

读取文件进行处理

```
fs.readFile('/a.txt','utf-8',(err,data =>{
  if(err){
    throw err
  } else {
    console.log(data)
  }
}))
```

上面代码中,readFile函数的第三个参数,就是回调函数,也就是任务的第二段.等到操作系统返回了`a.txt`这个文件后,回调函数才会执行

一个有趣的问题是,为什么Node约定,回调函数的第一个参数,必须是错误对象err,如果没有错误,该参数就是null

原因是执行分成两段,第一段完成以后,任务所在的上下文环境就已经结束了.在这以后抛出的错误,原来的上下文环境已经无法捕捉,只能当作参数,传入第二段.

---

**Promise**

回调函数本身并没有什么问题,它的问题出现在多个回调函数嵌套,假定读取A文件之后,再读取B文件,代码如下
```
fs.readFie(fileA,'utf-8',(err,data)=>{
  fs.readFile('fileB','utf-8',(err,data) =>{
    // ...
  })
})
```

不难想像,如果依次读取两个以上的文件,就会出现多生嵌套.代码不是纵向发展,很快就会乱成一团,无法管理.因为多个异步操作形成了耦合,只要有一个操作需要修改,它的上层回调和下层回调函数可能都要跟着修改.这种情况称为回调函数地狱.

Promise对象就是为了解决这个问题而提出的,它不是新的语法功能,而是一种新的写法,允许将回调函数的嵌套,改成链式调用.采用Promise,连续读取多个文件

```
var reafFile = require('fs-readfile-promise')

readFile(fileA).then(data=>{
  console.log(data.toString())
}).then(() => {
  return readFile(fileB)
}).then( data => {
  console.log(data.toString())
}).catch( err => {
  console.log(err)
})
```

上面代码中,使用了`fs-readfile.promise`模块,它的作用就是返回一个Promise版本readFile函数.Promise提供then方法加载回调函数,catch方法捕捉执行过程中抛出的错误

可以看到,Promise的写法只是回调函数的改进,使用then方法以后,异步任务的两段执行看得更清楚了,除此以外,并无新意.

Promise的最大问题是代码冗余,原来的任务被Promise包装了一下,不管什么操作,一眼看上去者是一堆then,原来的语义变得不是很清楚.